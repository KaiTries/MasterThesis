\section{Conceptual Framework}
The proposed framework provides a foundation for constructing open and evolvable Multi-Agent Systems (MAS) in which autonomous agents can coordinate without prior configuration or centralized orchestration. It introduces a set of core abstractions—agents, protocols, and the environment—that together define how interaction opportunities are represented, discovered, interpreted, and enacted.

\subsubsection*{4.2.1 Design Principles}

The proposed framework is guided by four key design principles that reflect the requirements of open, autonomous, and interoperable multi-agent environments:

\begin{enumerate}
    \item \textbf{Openness:} 
    Agents should be able to join or leave the environment at any time and dynamically discover available coordination mechanisms. No prior global knowledge of system participants or capabilities should be required.

    \item \textbf{Decentralization:} 
    Coordination must emerge from distributed interactions rather than rely on centralized control or orchestration. Interaction protocols serve as shared coordination artifacts rather than fixed interfaces.

    \item \textbf{Semantic Interoperability:}
    Interaction opportunities are described using machine-interpretable semantics, enabling heterogeneous agents to interpret roles, commitments, and goals consistently, even when developed independently.

    \item \textbf{Evolvability:} 
    The environment should support the publication, modification, and deprecation of interaction protocols at runtime without requiring agents to be reconfigured or redeployed. This ensures that coordination structures can adapt to changing tasks, partners, and system goals.
\end{enumerate}

\subsubsection*{4.2.2 Core Entities}

The framework rests on three core entities---\emph{agents}, the \emph{environment}, and \emph{interaction protocols}---that together enable dynamic, interpretable coordination in open multi-agent settings.

\paragraph{Agents.}
Agents are autonomous computational entities endowed with local knowledge and decision-making capabilities. Each agent maintains (i) a \emph{discovery} component to locate candidate interaction opportunities, (ii) a \emph{semantic interpreter} to parse protocol descriptions and associated ontologies, (iii) a \emph{protocol reasoner} to assess role fit, preconditions, and expected outcomes, and (iv) an \emph{enactment engine} to carry out the conversation or actions mandated by the chosen protocol. Agents interact by \emph{navigating and interpreting} Web resources rather than invoking fixed, precompiled interfaces, thereby preserving loose coupling and evolvability.

\paragraph{Environment.}
The environment is a distributed information space that exposes interaction opportunities as addressable Web resources. It aggregates (a) \emph{discovery affordances} (e.g., directories, search endpoints, typed links), (b) a \emph{protocol repository} whose items are reachable via hypermedia links, and (c) \emph{semantic descriptions} of roles, capabilities, and constraints. Conceptually, the environment serves as a \emph{coordination medium}: it does not orchestrate agents centrally; instead, it publishes machine-interpretable resources that agents can follow, interpret, and use.

\paragraph{Interaction Protocols.}
Interaction protocols are first-class coordination artifacts that specify the roles, information dependencies, commitments, and termination conditions governing multi-agent interaction. Protocols are represented declaratively and published as \emph{hypermedia documents enriched with semantic annotations}. Hypermedia controls (links, forms) indicate navigable next steps, whereas semantic vocabularies provide the meaning of roles, inputs/outputs, and constraints. This combination lets heterogeneous agents retrieve, understand, and enact protocols at runtime without prior bilateral agreements.

\vspace{0.25\baselineskip}
Together, these entities establish the substrate for open, runtime coordination: agents \emph{discover} protocol resources in the environment, \emph{interpret} their semantics to assess suitability and roles, and \emph{enact} the selected protocol with peers.

\subsubsection*{4.2.3 Conceptual Architecture}

Figure~\ref{fig:conceptual_framework} depicts the architecture at a high level. Coordination emerges through three recurrent phases---\emph{discovery}, \emph{interpretation}, and \emph{enactment}---mediated by hypermedia and semantics.

\paragraph{Discovery.}
Agents initiate coordination by querying or browsing the environment's discovery endpoints and typed links to locate relevant protocol resources. Hypermedia controls expose available interactions and their relationships (e.g., variants, required capabilities, related tasks), enabling agents to identify opportunities without prior global knowledge of participants.

\paragraph{Interpretation.}
Upon retrieving a protocol description, the agent's semantic interpreter and protocol reasoner parse the associated vocabularies to determine (i) admissible roles, (ii) required inputs and produced information, (iii) preconditions and effects, and (iv) constraints or policies. This step yields a \emph{local decision} about role adoption and protocol suitability with respect to the agent's goals and capabilities.

\paragraph{Enactment.}
If suitable, the agent commits to a role and invokes its enactment engine to carry out the interaction as guided by the protocol's hypermedia controls (e.g., following links, submitting forms/messages with required fields). Execution can involve peer-to-peer exchanges and additional environment lookups; progress and termination are defined by the protocol's declarative conditions rather than fixed message sequences.

\vspace{0.25\baselineskip}
This architecture preserves \emph{openness} (new protocols and agents can appear at any time), \emph{decentralization} (no central orchestrator is required), \emph{semantic interoperability} (shared meaning enables heterogeneous participants), and \emph{evolvability} (protocols can be added, updated, or deprecated without redeploying agents). In doing so, it operationalizes the hypothesis that hypermedia and semantics enable dynamic discovery and interpretable enactment of interaction protocols in open multi-agent environments.

\subsubsection*{4.2.4 Agent Autonomy Model}

A central challenge in open multi-agent systems is enabling agents to participate in coordination without requiring extensive prior knowledge of protocols, roles, or system participants. Traditional agent architectures often hardcode role assignments and protocol bindings, limiting flexibility and requiring reconfiguration when protocols evolve. The proposed framework addresses this through a \emph{goal-capability model} that separates \emph{what an agent wants to achieve} from \emph{how it achieves it}.

\paragraph{Goals and Capabilities.}
Each agent is configured with two fundamental attributes:
\begin{itemize}
    \item \textbf{Goals}: High-level objectives expressed as semantic types (e.g., \texttt{gr:Buy} to acquire goods, \texttt{gr:Sell} to transfer ownership). Goals represent the agent's motivation for participating in interactions but remain agnostic to specific protocols or roles.

    \item \textbf{Capabilities}: Concrete actions the agent can perform, expressed as capability identifiers (e.g., \texttt{Pay}, \texttt{Give}, \texttt{Deliver}). Capabilities define the agent's repertoire of executable behaviors but do not prescribe when or how they are invoked.
\end{itemize}

This separation enables \emph{protocol-agnostic agent design}: the same agent implementation can participate in different protocols (buying, leasing, auctioning) as long as a suitable mapping between its goals/capabilities and protocol roles exists. The agent need not be aware of protocol names or role labels a priori.

\paragraph{Semantic Role Reasoning.}
To bridge goals and capabilities with protocol roles, the framework introduces a \emph{semantic role reasoning mechanism}. Protocol descriptions are enriched with \emph{role semantics} that associate each role with (i) a semantic goal type (e.g., role \texttt{Buyer} serves goal \texttt{gr:Buy}) and (ii) required capabilities (e.g., \texttt{Buyer} requires \texttt{Pay}). During interpretation, the agent queries these role semantics and performs a matching algorithm:

\begin{enumerate}
    \item \textbf{Goal matching}: For each role in the protocol, compare the role's semantic goal type against the agent's declared goal. A match occurs when the agent's goal subsumes or is equivalent to the role's goal under the shared ontology.

    \item \textbf{Capability checking}: Verify that the agent possesses all capabilities required by the role. This ensures the agent can fulfill the role's commitments.

    \item \textbf{Role scoring}: Compute a match score based on goal alignment and capability coverage. The agent selects the role with the highest score, or declines participation if no suitable role exists.
\end{enumerate}

This reasoning process is fully automatic and runtime-driven: agents determine their roles by \emph{interpreting semantic metadata} rather than following hardcoded assignments. Consequently, the same agent can assume different roles in different contexts (e.g., \texttt{Buyer} in a purchase protocol, \texttt{Lessee} in a rental protocol) based solely on goal-capability matching.

\paragraph{Implications for Autonomy.}
The goal-capability model advances agent autonomy along two dimensions. First, it enables \emph{semantic flexibility}: agents can participate in protocols they were not explicitly designed for, provided role semantics are available. Second, it supports \emph{dynamic adaptation}: if an agent's goals or capabilities change (e.g., through learning or reconfiguration), role selection adjusts automatically without code modification. This contrasts sharply with traditional approaches where role bindings are static and embedded in agent logic.

\subsubsection*{4.2.5 Semantic Discovery Mechanisms}

Discovery is the cornerstone of openness in multi-agent coordination. For agents to operate without global directories or centralized registries, they must be able to locate relevant artifacts, protocols, and peers using only partial information and semantic descriptions. The framework introduces a \emph{class-based discovery model} that leverages hypermedia navigation and semantic types to enable robust, decentralized resource location.

\paragraph{Class-Based Artifact Discovery.}
Rather than requiring agents to know exact artifact URIs (which may change or vary across deployments), the framework allows agents to specify desired artifacts by their \emph{semantic class}. For instance, an agent seeking to purchase a rug specifies \texttt{ex:Rug} (a class from a shared ontology) rather than a specific URI like \texttt{http://example.org/artifacts/rug\#artifact}. This abstraction provides several benefits:
\begin{itemize}
    \item \textbf{Location independence}: Artifacts can be relocated or replicated without breaking agent logic.
    \item \textbf{Type-based reasoning}: Agents can discover any artifact satisfying a semantic type constraint, enabling generalization (e.g., ``any product'' rather than ``this specific product'').
    \item \textbf{Ontology-driven matching}: Subclass relationships and ontology axioms can expand discovery (e.g., \texttt{ex:PersianRug} is discoverable when querying for \texttt{ex:Rug}).
\end{itemize}

The discovery process operates via \emph{hypermedia crawling with semantic filtering}:
\begin{enumerate}
    \item The agent starts from a known base URI (e.g., an environment entry point) and follows typed links to discover workspaces (described below).
    \item At each workspace, the agent retrieves RDF metadata describing available artifacts and their semantic types.
    \item The agent performs a SPARQL query or RDF graph traversal to identify artifacts instantiating the target class (e.g., \texttt{?artifact rdf:type ex:Rug}).
    \item When a match is found, the agent retrieves the artifact's URI and associated metadata (e.g., linked protocols, policies, constraints).
\end{enumerate}

This approach combines the strengths of hypermedia (HATEOAS, decentralized navigation) and semantics (type-based reasoning, ontology support), enabling agents to discover resources without relying on search engines or central indexes.

\paragraph{Protocol Discovery from Artifacts.}
Once an artifact is located, the agent must identify interaction protocols applicable to that artifact. The framework embeds protocol references directly in artifact metadata using semantic links (e.g., \texttt{ex:artifact ex:hasProtocol <http://example.org/protocols/buy>}). By following these links, the agent retrieves protocol descriptions and role semantics, enabling interpretation and role reasoning as described in Section~4.2.4.

This \emph{artifact-centric discovery pattern} reflects real-world coordination: interaction opportunities are often associated with specific resources (e.g., purchasing a product, reserving a room, negotiating a contract). By anchoring protocols to artifacts, the framework ensures that discovery is contextual and relevant to the agent's goals.

\paragraph{Agent Discovery.}
In addition to locating artifacts and protocols, agents must discover peers capable of fulfilling complementary roles. The framework adopts \emph{W3C Thing Descriptions}~\cite{w3c:wot-td} to represent agent capabilities, endpoints, and metadata in a standardized, machine-readable format. Thing Descriptions expose:
\begin{itemize}
    \item Available capabilities (e.g., \texttt{Pay}, \texttt{Give})
    \item Communication endpoints (HTTP URIs, WebSocket addresses)
    \item Supported protocols and roles
    \item Security and policy constraints
\end{itemize}

Agents register their Thing Descriptions in workspaces (Section~4.2.6), making them discoverable to peers. During protocol interpretation, an agent queries the workspace for Thing Descriptions matching required capabilities (e.g., ``find agents with \texttt{Give} capability for the \texttt{Seller} role''), enabling dynamic partner selection.

\subsubsection*{4.2.6 Workspace-Based Coordination}

To organize artifacts, protocols, and agents in a scalable, decentralized manner, the framework introduces the concept of \emph{workspaces}. A workspace is a bounded coordination context—a logical container that aggregates related resources and provides a scope for discovery, interaction, and lifecycle management. Workspaces embody the environment's role as a coordination medium without imposing centralized control.

\paragraph{Workspace Structure.}
A workspace is represented as a hypermedia resource (typically at a base URI like \texttt{http://example.org/workspaces/marketplace}) with the following components:
\begin{itemize}
    \item \textbf{Artifact registry}: RDF metadata describing artifacts available in the workspace, including types, properties, and protocol links.
    \item \textbf{Agent registry}: Thing Descriptions of agents currently participating in the workspace, advertising their capabilities and endpoints.
    \item \textbf{Protocol repository}: Links to protocol specifications relevant to the workspace's domain (e.g., buying, selling, logistics).
    \item \textbf{Discovery affordances}: Typed links and query endpoints enabling agents to browse or search for resources (e.g., \texttt{GET /workspaces/marketplace/artifacts?type=ex:Rug}).
\end{itemize}

Workspaces are \emph{first-class resources}: they can be created, modified, and deprecated at runtime, and agents can join or leave dynamically. This design supports the openness and evolvability principles by allowing the environment to evolve without global reconfiguration.

\paragraph{Workspace Lifecycle.}
Agents interact with workspaces through a simple lifecycle:
\begin{enumerate}
    \item \textbf{Discovery}: The agent locates a workspace by crawling hypermedia links from a known base URI, guided by semantic types (e.g., ``find a workspace containing artifacts of type \texttt{ex:Rug}'').
    \item \textbf{Joining}: The agent registers its Thing Description in the workspace's agent registry, making itself discoverable to peers. This step is analogous to entering a coordination space.
    \item \textbf{Interaction}: The agent discovers artifacts, protocols, and peers within the workspace, performs role reasoning, and initiates protocol enactment.
    \item \textbf{Leaving}: When coordination is complete or the agent's goals change, it deregisters from the workspace, removing its Thing Description and releasing resources.
\end{enumerate}

This lifecycle ensures that workspace membership is \emph{dynamic and ephemeral}, reflecting the transient nature of coordination in open systems. Agents are not bound to workspaces indefinitely; they join when relevant interactions are available and leave when their goals are satisfied.

\paragraph{Decentralized Workspace Management.}
Workspaces are managed in a decentralized fashion: no single authority controls workspace creation or membership. Instead, workspace management policies are embedded in workspace metadata (e.g., access control lists, membership constraints, protocol whitelists) and enforced by the hosting infrastructure (e.g., Yggdrasil platform). This design preserves decentralization while enabling flexible governance (e.g., public vs. private workspaces, domain-specific policies).

Importantly, workspaces do not orchestrate interactions; they merely \emph{publish resources} that agents interpret and enact autonomously. Coordination emerges from agents' decentralized decisions rather than from centralized workspace logic.

\subsubsection*{4.2.7 Dynamic Role Negotiation}

In open multi-agent systems, role assignment cannot be predetermined: participants are unknown in advance, capabilities vary, and coordination structures must form dynamically. The framework addresses this challenge through a \emph{universal metaprotocol} that enables agents to negotiate role bindings at runtime, independent of the specific application protocol being enacted.

\paragraph{The Metaprotocol Abstraction.}
The metaprotocol is itself an interaction protocol—formalized using the same declarative specification language (BSPL, described in Section~4.2.8)—that governs role negotiation. It defines a three-step conversation:
\begin{enumerate}
    \item \textbf{Role offering}: An initiator agent (having identified a protocol and selected a role for itself) discovers candidate agents in the workspace and sends \texttt{OfferRole} messages proposing specific roles. Each offer includes the protocol specification, the proposed role, and a unique negotiation identifier.

    \item \textbf{Acceptance/rejection}: Candidate agents receive role offers, perform semantic role reasoning (Section~4.2.4) to assess fit, and respond with \texttt{AcceptRole} or \texttt{RejectRole} messages. Acceptance constitutes a commitment to enact the proposed role.

    \item \textbf{System formation}: Once all required roles are filled, the initiator broadcasts a \texttt{SystemDetails} message containing the complete role-to-agent bindings. Upon receipt, all participants transition from negotiation to enactment, executing the application protocol with their assigned roles.
\end{enumerate}

This metaprotocol is \emph{universal}: it applies to any application protocol, regardless of domain or complexity. The same negotiation logic handles role assignment for purchasing, logistics, auctions, or any other coordination scenario, provided role semantics are available.

\paragraph{Separation of Negotiation and Enactment.}
By isolating role negotiation in a dedicated metaprotocol, the framework achieves a clean separation of concerns:
\begin{itemize}
    \item \textbf{Negotiation logic} is protocol-independent and reusable, reducing implementation complexity.
    \item \textbf{Application protocols} focus solely on domain-specific interactions (e.g., payment, delivery), assuming roles are pre-bound.
    \item \textbf{Formal guarantees} can be established for the metaprotocol (e.g., deadlock-freedom, termination) independently of application protocols, enhancing reliability.
\end{itemize}

This separation mirrors architectural patterns in distributed systems (e.g., service discovery vs. service invocation) and provides a foundation for scalable, composable coordination.

\paragraph{Autonomous Role Selection.}
A key feature of the metaprotocol is that role acceptance is \emph{agent-driven} rather than externally assigned. When a candidate receives a role offer, it autonomously evaluates whether it can fulfill the role using its semantic reasoner (checking goal alignment and capability availability). This autonomy ensures that agents only commit to roles they are capable of performing, reducing coordination failures and enhancing system robustness.

Moreover, the metaprotocol supports \emph{negotiation failure handling}: if no suitable candidates accept a role, the initiator can retry with different agents, adjust the protocol, or abandon the interaction. This flexibility is essential in open environments where agent availability and capabilities are unpredictable.

\subsubsection*{4.2.8 Formal Protocol Specifications}

To ensure correctness and reliability in multi-agent coordination, the framework grounds interaction protocols in a formal specification language: \emph{Blindingly Simple Protocol Language (BSPL)}~\cite{singh:bspl}. BSPL provides a declarative, verifiable foundation for defining protocols, enabling automated reasoning about protocol properties and runtime enactment guarantees.

\paragraph{BSPL Foundations.}
BSPL represents protocols as collections of \emph{roles}, \emph{parameters}, and \emph{messages}. Each message specifies (i) the sender and receiver roles, (ii) input parameters (information required to send the message), and (iii) output parameters (information produced by the message). Protocols are subject to constraints ensuring \emph{enactability} (every message can eventually be sent) and \emph{information safety} (parameters are never sent before being received).

For example, a simple purchase protocol might include:
\begin{itemize}
    \item Roles: \texttt{Buyer}, \texttt{Seller}
    \item Messages:
    \begin{itemize}
        \item \texttt{Pay[Buyer $\to$ Seller]}: inputs: \texttt{buyID, itemID, money}; outputs: \texttt{buyID, itemID, money}
        \item \texttt{Give[Seller $\to$ Buyer]}: inputs: \texttt{buyID, itemID, money}; outputs: \texttt{buyID, itemID, money, item}
    \end{itemize}
\end{itemize}

BSPL's declarative nature enables agents to interpret protocols without requiring procedural code: the message dependencies and role obligations are explicit, supporting runtime reasoning and adaptation.

\paragraph{Formal Verification.}
A critical advantage of BSPL is its amenability to automated verification. The framework employs SAT-based model checking to verify protocol properties:
\begin{itemize}
    \item \textbf{Deadlock-freedom}: No protocol state exists where all roles are waiting for messages from others.
    \item \textbf{Liveness}: All messages can eventually be sent under appropriate conditions.
    \item \textbf{Information safety}: Parameters flow correctly without premature disclosure or unavailability.
\end{itemize}

These guarantees are established \emph{before deployment}, ensuring that any protocol published in the environment is correct by construction. This eliminates a major source of coordination failures in open systems: protocol misspecification.

\paragraph{Integration with Semantics.}
While BSPL provides formal structure, it does not inherently carry semantic meaning. The framework bridges this gap by \emph{annotating BSPL protocols with RDF metadata}. Role semantics (goals, capabilities) and message semantics (parameter types, ontological relationships) are attached to protocol specifications, enabling agents to perform semantic reasoning (Section~4.2.4) while retaining formal correctness guarantees.

This integration represents a novel contribution: existing work on semantic protocols~\cite{semantic-protocols-ref} or formal protocols~\cite{formal-protocols-ref} typically treats semantics and formal verification as separate concerns. By unifying them, the framework provides both \emph{interpretability} (agents understand what protocols mean) and \emph{correctness} (agents trust that protocols behave as specified).

\subsubsection*{4.2.9 Layered Architectural Integration}

The conceptual elements described above—autonomy, discovery, workspaces, negotiation, and formal protocols—are integrated through a three-layer architecture that progressively abstracts coordination complexity.

\paragraph{Layer 1: Protocol Engine.}
The foundational layer implements BSPL protocol enactment. It provides:
\begin{itemize}
    \item A protocol parser that loads BSPL specifications.
    \item A message validation engine that checks message ordering and parameter dependencies.
    \item An event-driven enactment engine that triggers message sends and receives based on protocol state.
    \item Formal verification integration ensuring protocol correctness.
\end{itemize}

This layer is \emph{semantic-agnostic}: it operates purely on formal protocol structures without interpreting goals, capabilities, or semantic types. Its responsibility is to guarantee correct enactment once roles are assigned and protocols are selected.

\paragraph{Layer 2: Hypermedia Coordination Layer.}
The middle layer extends the protocol engine with hypermedia and semantic capabilities. It implements:
\begin{itemize}
    \item Workspace discovery and lifecycle management (joining, leaving, updating).
    \item Class-based artifact discovery using RDF and SPARQL.
    \item Protocol discovery from artifact metadata.
    \item Agent discovery via Thing Descriptions.
    \item Semantic role reasoning (goal-capability matching).
    \item Dynamic role negotiation using the metaprotocol.
\end{itemize}

This layer orchestrates high-level coordination workflows: from discovering workspaces to reasoning about roles to negotiating bindings. It consumes semantic metadata and produces role assignments that are passed down to the protocol engine for enactment.

\paragraph{Layer 3: Agent-Level Tools and Utilities.}
The top layer provides reusable utilities and abstractions for agent developers:
\begin{itemize}
    \item RDF parsing and SPARQL query execution.
    \item Hypermedia link traversal and resource fetching.
    \item Thing Description generation and registration.
    \item Logging, monitoring, and debugging support.
\end{itemize}

This layer shields agent developers from low-level details, offering a high-level API: agents specify goals, capabilities, and target artifact classes, and the framework handles discovery, reasoning, negotiation, and enactment autonomously.

\paragraph{Architectural Benefits.}
This layered design achieves several objectives:
\begin{itemize}
    \item \textbf{Separation of concerns}: Formal verification, semantic reasoning, and hypermedia navigation are isolated in distinct layers, enhancing maintainability and testability.
    \item \textbf{Reusability}: The protocol engine and hypermedia layer are domain-independent and can be reused across diverse coordination scenarios.
    \item \textbf{Extensibility}: New semantic vocabularies, discovery mechanisms, or protocol languages can be integrated by extending individual layers without disrupting others.
    \item \textbf{Progressive disclosure}: Agent developers can engage with the architecture at different abstraction levels—using high-level APIs for simple cases, or diving into lower layers for custom behaviors.
\end{itemize}

Collectively, the architecture instantiates the conceptual framework in a modular, scalable, and verifiable manner.

\subsubsection*{4.2.10 Synthesis and Summary}

This chapter has presented a conceptual framework for open, autonomous multi-agent coordination grounded in hypermedia and semantics. The framework addresses the core challenge of enabling heterogeneous agents to discover, interpret, and enact interaction protocols at runtime without prior configuration or centralized orchestration.

Four design principles—openness, decentralization, semantic interoperability, and evolvability—guide the framework's construction. These principles are realized through a set of interlocking concepts:
\begin{itemize}
    \item \textbf{Goal-capability autonomy model}: Agents specify high-level goals and concrete capabilities, enabling protocol-agnostic reasoning and dynamic role selection.
    \item \textbf{Semantic discovery mechanisms}: Class-based artifact discovery, protocol retrieval from metadata, and agent discovery via Thing Descriptions enable decentralized resource location.
    \item \textbf{Workspace-based coordination}: Workspaces provide bounded contexts for organizing artifacts, protocols, and agents, supporting scalable and ephemeral coordination.
    \item \textbf{Dynamic role negotiation}: A universal metaprotocol separates role binding from protocol enactment, enabling autonomous, runtime role assignment.
    \item \textbf{Formal protocol specifications}: BSPL grounds protocols in verifiable formal semantics, ensuring correctness while supporting semantic annotation.
    \item \textbf{Layered architecture}: A three-layer design integrates formal verification, semantic reasoning, and hypermedia navigation in a modular, extensible structure.
\end{itemize}

Together, these concepts operationalize the hypothesis that hypermedia and semantics can enable interpretable, autonomous coordination in open multi-agent environments. By combining the navigability and loose coupling of hypermedia with the shared meaning and reasoning capabilities of semantics, the framework provides a foundation for building evolvable, decentralized multi-agent systems.

The next chapter describes the implementation of this framework and evaluates its effectiveness through empirical experiments and case studies.
