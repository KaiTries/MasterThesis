\section{Implementation}

This chapter describes the implementation of the conceptual framework presented in Chapter~4. The implementation realizes the design principles of openness, decentralization, semantic interoperability, and evolvability through a modular, layered architecture instantiated in Python. The system integrates formal protocol specifications (BSPL), semantic web technologies (RDF, SPARQL, W3C Thing Descriptions), and hypermedia principles (HATEOAS) to enable autonomous multi-agent coordination.

\subsection{Implementation Overview}

The implementation consists of approximately 2,000 lines of core code organized into three architectural layers, each addressing distinct coordination concerns. Figure~\ref{fig:implementation_architecture} depicts the component structure and dependencies.

\paragraph{Design Objectives.}
The implementation was guided by four technical objectives derived from the conceptual framework:
\begin{enumerate}
    \item \textbf{Modularity}: Each layer should be independently testable and reusable across different application domains.
    \item \textbf{Declarative Specification}: Protocols, role semantics, and artifact metadata should be expressed declaratively (BSPL, RDF) rather than embedded in code.
    \item \textbf{Runtime Flexibility}: Agents should discover resources, reason about roles, and negotiate bindings at runtime without recompilation or reconfiguration.
    \item \textbf{Standards Compliance}: The implementation should leverage W3C standards (RDF, SPARQL, Thing Descriptions) and established protocols (HTTP, JSON) to ensure interoperability.
\end{enumerate}

\paragraph{Technology Stack.}
The implementation builds on the following technologies:
\begin{itemize}
    \item \textbf{Programming Language}: Python 3.10+ with asyncio for asynchronous agent execution.
    \item \textbf{Protocol Specification}: BSPL (Blindingly Simple Protocol Language)~\cite{singh:bspl} with custom Python parser and enactment engine.
    \item \textbf{Semantic Technologies}: RDFLib~\cite{rdflib} for RDF parsing and graph manipulation; SPARQL for querying semantic metadata.
    \item \textbf{Hypermedia Platform}: Yggdrasil~\cite{yggdrasil}, a hypermedia middleware providing workspace hosting, artifact management, and HTTP-based resource access.
    \item \textbf{Agent Metadata}: W3C Thing Descriptions~\cite{w3c:wot-td} in JSON-LD format for advertising agent capabilities and endpoints.
    \item \textbf{Ontologies}: GoodRelations~\cite{goodrelations} for commerce concepts (buying, selling, products); custom domain ontologies for artifacts and protocols.
    \item \textbf{Communication}: HTTP REST APIs for environment interaction; direct TCP/HTTP for peer-to-peer agent messaging.
\end{itemize}

This stack balances standardization (W3C, HTTP) with flexibility (custom BSPL enactment, domain ontologies), enabling both interoperability and extensibility.

\subsection{Layer 1: Protocol Engine}

The foundational layer implements BSPL protocol enactment and formal verification, providing a semantic-agnostic engine for executing interaction protocols. This layer is realized primarily through two classes: \texttt{Adapter} and \texttt{MetaAdapter}, located in \texttt{bspl/src/bspl/adapter/}.

\subsubsection{Adapter: Protocol Enactment}

The \texttt{Adapter} class (\texttt{core.py}, $\sim$800 lines) is responsible for loading, validating, and enacting BSPL protocols. It maintains protocol state, enforces message ordering constraints, and dispatches events to agent logic.

\paragraph{Core Responsibilities.}
\begin{itemize}
    \item \textbf{Protocol Registration}: The \texttt{add\_protocol(protocol\_spec)} method parses BSPL specifications, extracting roles, parameters, messages, and information dependencies. Protocols are stored in an internal registry indexed by protocol name.

    \item \textbf{System Instantiation}: The \texttt{add\_system(system\_id, protocol\_name, role\_bindings)} method creates a protocol instance (called a ``system'') with specific role-to-agent mappings. Multiple systems can execute concurrently for the same protocol.

    \item \textbf{Message Validation}: Before sending or processing a message, the adapter validates that (i) all required input parameters are available, (ii) the message respects protocol ordering constraints, and (iii) the sender/receiver roles match the system bindings.

    \item \textbf{Event-Driven Enactment}: The adapter provides two event handlers:
    \begin{itemize}
        \item \texttt{reaction(message)}: Invoked when a message is received. Updates protocol state, checks if new messages are now enabled, and triggers agent callbacks.
        \item \texttt{generator()}: Returns a list of messages the agent is currently enabled to send based on protocol state and available parameters.
    \end{itemize}

    \item \textbf{Message Dispatch}: The \texttt{initiate\_protocol(message\_type, params)} method constructs and sends messages according to BSPL specifications, using the communication layer to deliver them to peer agents.
\end{itemize}

\paragraph{BSPL Representation.}
BSPL protocols are represented as JSON objects with the following structure:
\begin{verbatim}
{
  "name": "Buy",
  "roles": ["Buyer", "Seller"],
  "parameters": {
    "buyID": {"key": true},
    "itemID": {},
    "money": {},
    "item": {"out": true}
  },
  "messages": [
    {
      "name": "Pay",
      "sender": "Buyer",
      "receiver": "Seller",
      "ins": ["buyID", "itemID", "money"],
      "outs": ["buyID", "itemID", "money"]
    },
    {
      "name": "Give",
      "sender": "Seller",
      "receiver": "Buyer",
      "ins": ["buyID", "itemID", "money"],
      "outs": ["buyID", "itemID", "money", "item"]
    }
  ]
}
\end{verbatim}
This declarative representation allows protocols to be stored in files, transmitted over the network, and interpreted at runtime without code generation.

\paragraph{Formal Verification.}
The adapter integrates with a SAT-based verifier (Mambo~\cite{mambo}) to check protocol correctness before enactment. Verification queries include:
\begin{itemize}
    \item \textbf{Enactability}: Can all messages eventually be sent under some execution path?
    \item \textbf{Deadlock-freedom}: Is there any reachable state where all roles are blocked waiting for messages?
    \item \textbf{Information safety}: Are there any messages where required input parameters might be unavailable?
\end{itemize}
Protocols that fail verification are rejected during \texttt{add\_protocol()}, ensuring correctness guarantees before deployment.

\subsubsection{MetaAdapter: Dynamic Role Negotiation}

The \texttt{MetaAdapter} class (\texttt{meta\_adapter.py}, $\sim$400 lines) extends \texttt{Adapter} with role negotiation capabilities. It implements the universal metaprotocol described in Section~4.2.7, enabling agents to form protocol systems dynamically.

\paragraph{Metaprotocol Implementation.}
The metaprotocol itself is defined as a BSPL specification with three message types:
\begin{verbatim}
{
  "name": "RoleNegotiation",
  "roles": ["Initiator", "Candidate"],
  "messages": [
    {
      "name": "OfferRole",
      "sender": "Initiator",
      "receiver": "Candidate",
      "ins": ["uuid", "protocol", "role"],
      "outs": ["uuid", "protocol", "role"]
    },
    {
      "name": "AcceptRole",
      "sender": "Candidate",
      "receiver": "Initiator",
      "ins": ["uuid", "protocol", "role"],
      "outs": ["uuid", "protocol", "role", "acceptance"]
    },
    {
      "name": "SystemDetails",
      "sender": "Initiator",
      "receiver": "Candidate",
      "ins": ["uuid", "role_bindings"],
      "outs": ["uuid", "role_bindings"]
    }
  ]
}
\end{verbatim}

\paragraph{Key Methods.}
\begin{itemize}
    \item \texttt{propose\_system(protocol, my\_role, candidate\_agents)}: Initiates role negotiation. The initiator selects a role for itself, discovers candidate agents from the workspace, and sends \texttt{OfferRole} messages to appropriate candidates based on capability matching.

    \item \texttt{handle\_offer\_role(message)}: Invoked when a candidate receives a role offer. Triggers semantic role reasoning (Section~5.3.1) to assess fit. If suitable, responds with \texttt{AcceptRole}; otherwise, sends \texttt{RejectRole}.

    \item \texttt{handle\_accept\_role(message)}: Tracks acceptances. Once all roles are filled, constructs the complete role-binding map and broadcasts \texttt{SystemDetails} to all participants.

    \item \texttt{handle\_system\_details(message)}: Transitions from negotiation to enactment. Registers the system with the base \texttt{Adapter} and enables application protocol execution.
\end{itemize}

\paragraph{Negotiation State Management.}
\texttt{MetaAdapter} maintains negotiation state for concurrent proposal processes using UUIDs. This allows multiple agents to negotiate different protocols simultaneously without interference. State includes:
\begin{itemize}
    \item Pending role offers (awaiting responses)
    \item Accepted roles (committed agents)
    \item Rejected roles (requiring retry or alternative candidates)
    \item Timeout handlers (to abandon stalled negotiations)
\end{itemize}

\subsection{Layer 2: Hypermedia Coordination Layer}

The middle layer extends the protocol engine with hypermedia navigation, semantic reasoning, and workspace management. It is implemented in two main components: \texttt{HypermediaMetaAdapter} and \texttt{HypermediaTools}, located in \texttt{HypermediaInteractionProtocols/agents/}.

\subsubsection{HypermediaMetaAdapter: Orchestration}

\texttt{HypermediaMetaAdapter} (\texttt{HypermediaMetaAdapter.py}, 556 lines) orchestrates high-level agent workflows by composing discovery, reasoning, and negotiation operations. It extends \texttt{MetaAdapter} with hypermedia-aware methods.

\paragraph{Goal-Capability Configuration.}
Agents instantiate \texttt{HypermediaMetaAdapter} with goal and capability declarations:
\begin{verbatim}
adapter = HypermediaMetaAdapter(
    base_uri="http://localhost:8080",
    goal_type="http://purl.org/goodrelations/v1#Buy",
    capabilities={"Pay"},
    goal_artifact_class="http://example.org/Rug",
    auto_discover_workspace=True
)
\end{verbatim}
This configuration drives all subsequent discovery and reasoning operations, eliminating the need for hardcoded URIs or role names.

\paragraph{Automated Discovery Workflow.}
When \texttt{auto\_discover\_workspace=True}, the adapter executes the following workflow during initialization:
\begin{enumerate}
    \item \textbf{Workspace Discovery}: Calls \texttt{HypermediaTools.discover\_workspace\_by\_artifact\_class()} to locate a workspace containing artifacts of the specified class (e.g., \texttt{ex:Rug}). Uses depth-first hypermedia crawling from \texttt{base\_uri}.

    \item \textbf{Workspace Joining}: Registers the agent's Thing Description in the discovered workspace using \texttt{join\_workspace()}.

    \item \textbf{Artifact Retrieval}: Retrieves the discovered artifact's URI and metadata.

    \item \textbf{Protocol Discovery}: Queries artifact metadata for linked protocols using SPARQL (\texttt{ex:artifact ex:hasProtocol ?protocol}).

    \item \textbf{Protocol Fetching}: Downloads the BSPL protocol specification from the discovered URI and registers it with the base \texttt{Adapter}.
\end{enumerate}
This workflow requires only a base URI and semantic types; all specific URIs (workspace, artifact, protocol) are discovered at runtime.

\paragraph{Semantic Role Reasoning.}
The \texttt{reason\_my\_role(protocol)} method determines the agent's role in a protocol:
\begin{enumerate}
    \item Fetches role semantics metadata for the protocol (RDF describing each role's goal and required capabilities).
    \item For each role in the protocol:
    \begin{itemize}
        \item Checks if the role's semantic goal matches the agent's \texttt{goal\_type} (e.g., role has \texttt{gr:Buy}, agent seeks \texttt{gr:Buy}).
        \item Verifies that the agent's \texttt{capabilities} include all capabilities required by the role.
        \item Computes a match score (0.0--1.0) based on goal alignment and capability coverage.
    \end{itemize}
    \item Selects the role with the highest score, or returns \texttt{None} if no suitable role exists.
\end{enumerate}
This method delegates to \texttt{HypermediaTools.reason\_role\_for\_goal()}, described below.

\paragraph{Partner Discovery and System Proposal.}
Once the agent determines its own role, it must find partners for complementary roles:
\begin{enumerate}
    \item \texttt{discover\_candidate\_agents()}: Queries the workspace's agent registry for Thing Descriptions. Filters agents based on required capabilities for unfilled roles (e.g., ``find agents with \texttt{Give} capability for \texttt{Seller} role'').

    \item \texttt{discover\_and\_propose\_system()}: High-level method that:
    \begin{itemize}
        \item Determines the agent's role via \texttt{reason\_my\_role()}.
        \item Discovers candidates for other roles.
        \item Invokes \texttt{MetaAdapter.propose\_system()} to initiate role negotiation.
    \end{itemize}
\end{enumerate}

\paragraph{Workspace Lifecycle Management.}
\texttt{HypermediaMetaAdapter} provides methods for managing workspace membership:
\begin{itemize}
    \item \texttt{join\_workspace(workspace\_uri)}: Generates a Thing Description for the agent (including capabilities, endpoint, supported protocols) and POSTs it to the workspace's agent registry.

    \item \texttt{leave\_workspace(workspace\_uri)}: Deregisters the agent's Thing Description via HTTP DELETE.

    \item \texttt{update\_thing\_description()}: Modifies the agent's advertised capabilities or metadata (e.g., after learning new capabilities).
\end{itemize}

\subsubsection{HypermediaTools: Discovery and Reasoning Utilities}

\texttt{HypermediaTools} (\texttt{HypermediaTools.py}, 1,265 lines) provides reusable functions for hypermedia navigation, semantic queries, and RDF manipulation. It serves as the utility layer for \texttt{HypermediaMetaAdapter} and can be used standalone.

\paragraph{Workspace Discovery.}
The core workspace discovery algorithm is implemented in \texttt{discover\_workspace\_by\_artifact\_class(base\_uri, artifact\_class)}:
\begin{verbatim}
def discover_workspace_by_artifact_class(base_uri, artifact_class):
    visited = set()
    queue = [base_uri]

    while queue:
        current_uri = queue.pop(0)
        if current_uri in visited:
            continue
        visited.add(current_uri)

        # Fetch workspace metadata (RDF)
        graph = fetch_rdf(current_uri)

        # Check for artifacts of target class
        artifacts = query_artifacts_by_class(graph, artifact_class)
        if artifacts:
            return (current_uri, artifacts[0])

        # Follow typed links to other workspaces
        linked_workspaces = extract_workspace_links(graph)
        queue.extend(linked_workspaces)

    return None
\end{verbatim}
This depth-first search combines hypermedia traversal (following links) with semantic filtering (SPARQL queries for artifact classes).

\paragraph{Semantic Role Reasoning.}
The role reasoning algorithm is implemented in \texttt{reason\_role\_for\_goal(protocol, goal\_type, capabilities)}:
\begin{verbatim}
def reason_role_for_goal(protocol, goal_type, capabilities):
    role_semantics = fetch_role_semantics(protocol)
    best_role = None
    best_score = 0.0

    for role in protocol.roles:
        semantics = role_semantics.get(role)
        if not semantics:
            continue

        # Goal matching
        goal_match = (semantics['goal'] == goal_type)

        # Capability checking
        required_caps = semantics['required_capabilities']
        has_all_caps = required_caps.issubset(capabilities)

        # Scoring
        score = 1.0 if (goal_match and has_all_caps) else 0.0
        if score > best_score:
            best_score = score
            best_role = role

    return best_role if best_score > 0 else None
\end{verbatim}
The scoring function can be extended to handle partial matches, capability hierarchies, and ontology reasoning.

\paragraph{RDF and SPARQL Operations.}
\texttt{HypermediaTools} wraps RDFLib to provide domain-specific queries:
\begin{itemize}
    \item \texttt{get\_artifacts\_in(workspace\_uri)}: Returns all artifacts in a workspace with their types and metadata.
    \item \texttt{get\_agents(workspace\_uri)}: Retrieves Thing Descriptions of agents registered in the workspace.
    \item \texttt{get\_protocol\_uri\_for\_artifact(artifact\_uri)}: Queries artifact metadata for linked protocols.
    \item \texttt{get\_role\_semantics(protocol\_uri)}: Fetches role semantics (goal, capabilities) from RDF annotations.
\end{itemize}
These methods encapsulate SPARQL queries, shielding higher layers from RDF syntax.

\paragraph{Thing Description Generation.}
\texttt{generate\_thing\_description(agent\_id, capabilities, endpoint)} constructs W3C-compliant Thing Descriptions in JSON-LD:
\begin{verbatim}
{
  "@context": "https://www.w3.org/2019/wot/td/v1",
  "id": "http://example.org/agents/buyer-123",
  "title": "Buyer Agent",
  "properties": {
    "capabilities": {
      "type": "array",
      "items": {"type": "string"},
      "enum": ["Pay", "Receive"]
    }
  },
  "actions": {
    "sendMessage": {
      "forms": [{
        "href": "http://localhost:5000/messages",
        "htv:methodName": "POST"
      }]
    }
  }
}
\end{verbatim}
This standardized format enables interoperability with other WoT-compliant systems.

\subsection{Layer 3: Agent-Level Implementation}

The top layer demonstrates how agents use the hypermedia coordination layer to achieve autonomous behavior. Three example agents illustrate progressive autonomy levels.

\subsubsection{Buyer Agent with Role Reasoning}

The most advanced agent (\texttt{buyer\_agent\_with\_role\_reasoning.py}, $\sim$150 lines) achieves full autonomy:
\begin{verbatim}
async def main():
    # Agent configured with goals and capabilities only
    adapter = HypermediaMetaAdapter(
        base_uri="http://localhost:8080",
        goal_type="http://purl.org/goodrelations/v1#Buy",
        capabilities={"Pay"},
        goal_artifact_class="http://example.org/Rug",
        auto_discover_workspace=True
    )

    # All discovery, reasoning, negotiation happens automatically
    await adapter.discover_and_propose_system()

    # Protocol enactment
    await adapter.wait_for_system_formation()
    await adapter.execute_protocol()
\end{verbatim}
The agent specifies \emph{what} it wants (\texttt{gr:Buy} a \texttt{ex:Rug}) and \emph{what} it can do (\texttt{Pay}), but not \emph{how} (no workspace URIs, artifact URIs, protocol names, or role names). Everything else is discovered and reasoned at runtime.

\subsubsection{Bazaar Agent (Seller)}

The complementary seller agent (\texttt{bazaar\_agent.py}, $\sim$200 lines) illustrates reactive behavior:
\begin{verbatim}
async def main():
    adapter = HypermediaMetaAdapter(
        base_uri="http://localhost:8080",
        goal_type="http://purl.org/goodrelations/v1#Sell",
        capabilities={"Give"}
    )

    # Join workspace but don't initiate
    workspace_uri = "http://localhost:8080/workspaces/marketplace"
    await adapter.join_workspace(workspace_uri)

    # Listen for role offers
    adapter.on("OfferRole", handle_role_offer)
    await adapter.run()

async def handle_role_offer(message):
    # Semantic reasoning to assess fit
    role = message['role']
    protocol = message['protocol']

    can_fulfill = await adapter.reason_my_role(protocol) == role

    if can_fulfill:
        await adapter.send_accept_role(message)
    else:
        await adapter.send_reject_role(message)
\end{verbatim}
This agent reactively responds to negotiation requests, using semantic reasoning to determine if it can fulfill proposed roles.

\subsection{Implementation of Key Innovations}

This section describes how the three core innovations (semantic role reasoning, class-based discovery, dynamic negotiation) are realized in code.

\subsubsection{Semantic Role Reasoning Implementation}

Semantic role reasoning integrates three components:

\paragraph{1. Role Semantics Metadata.}
Role semantics are expressed in RDF/Turtle and hosted alongside protocols:
\begin{verbatim}
@prefix ex: <http://example.org/> .
@prefix gr: <http://purl.org/goodrelations/v1#> .

ex:BuyProtocol a ex:Protocol ;
    ex:hasRole ex:BuyerRole, ex:SellerRole .

ex:BuyerRole a ex:Role ;
    ex:roleName "Buyer" ;
    ex:hasGoal gr:Buy ;
    ex:requiresCapability "Pay" .

ex:SellerRole a ex:Role ;
    ex:roleName "Seller" ;
    ex:hasGoal gr:Sell ;
    ex:requiresCapability "Give" .
\end{verbatim}

\paragraph{2. SPARQL Queries for Role Semantics.}
\texttt{HypermediaTools.get\_role\_semantics(protocol\_uri)} executes SPARQL queries to extract role metadata:
\begin{verbatim}
SELECT ?role ?roleName ?goal ?capability
WHERE {
    ?protocol ex:hasRole ?role .
    ?role ex:roleName ?roleName ;
          ex:hasGoal ?goal ;
          ex:requiresCapability ?capability .
}
\end{verbatim}
Results are parsed into a dictionary mapping role names to semantic descriptors.

\paragraph{3. Goal-Capability Matching Algorithm.}
The matching algorithm (in \texttt{HypermediaTools.score\_role\_match()}) computes:
\begin{verbatim}
def score_role_match(role_goal, role_caps, agent_goal, agent_caps):
    goal_score = 1.0 if role_goal == agent_goal else 0.0

    if not role_caps.issubset(agent_caps):
        return 0.0  # Agent lacks required capabilities

    capability_score = len(role_caps & agent_caps) / len(role_caps)

    return (goal_score * 0.7) + (capability_score * 0.3)
\end{verbatim}
This scoring function prioritizes goal alignment (70\%) over capability coverage (30\%), reflecting that goals define intent while capabilities enable execution.

\subsubsection{Class-Based Discovery Implementation}

Class-based artifact discovery combines hypermedia crawling with SPARQL filtering:

\paragraph{1. Artifact Metadata in RDF.}
Artifacts are annotated with semantic types:
\begin{verbatim}
@prefix ex: <http://example.org/> .

<http://localhost:8080/artifacts/rug#artifact> a ex:Rug ;
    ex:hasProtocol <http://localhost:8080/protocols/buy> ;
    ex:price "100"^^xsd:decimal ;
    ex:currency "USD" .
\end{verbatim}

\paragraph{2. Workspace Crawling.}
\texttt{HypermediaTools.discover\_workspace\_by\_artifact\_class()} implements breadth-first search:
\begin{verbatim}
def discover_workspace_by_artifact_class(base_uri, artifact_class):
    visited = set()
    queue = deque([base_uri])

    while queue:
        workspace_uri = queue.popleft()
        if workspace_uri in visited:
            continue
        visited.add(workspace_uri)

        logger.info(f"Exploring workspace: {workspace_uri}")

        # Fetch workspace RDF
        graph = fetch_rdf_graph(workspace_uri)

        # Query for artifacts of target class
        query = f"""
            SELECT ?artifact WHERE {{
                ?artifact rdf:type <{artifact_class}> .
            }}
        """
        results = graph.query(query)

        if results:
            artifact_uri = str(list(results)[0][0])
            return (workspace_uri, artifact_uri)

        # Extract links to sub-workspaces
        for link in graph.objects(predicate=EX.hasWorkspace):
            queue.append(str(link))

    return None
\end{verbatim}
This implementation handles arbitrary workspace hierarchies and scales to large environments through visited-set tracking.

\paragraph{3. Artifact Class Resolution.}
To support ontology reasoning (e.g., \texttt{ex:PersianRug} is a subclass of \texttt{ex:Rug}), the SPARQL query can be extended:
\begin{verbatim}
SELECT ?artifact WHERE {
    ?artifact rdf:type ?type .
    ?type rdfs:subClassOf* <{artifact_class}> .
}
\end{verbatim}
This transitive closure query matches artifacts of the target class or any subclass.

\subsubsection{Dynamic Role Negotiation Implementation}

The metaprotocol implementation coordinates three message handlers:

\paragraph{1. OfferRole Handler (Candidate Agent).}
\begin{verbatim}
async def handle_offer_role(self, message):
    protocol_uri = message['protocol']
    proposed_role = message['role']
    negotiation_id = message['uuid']

    # Download and parse protocol
    protocol_spec = await fetch_protocol(protocol_uri)
    self.add_protocol(protocol_spec)

    # Semantic role reasoning
    my_suitable_role = self.reason_my_role(protocol_spec)

    if my_suitable_role == proposed_role:
        # Accept the role
        response = {
            'type': 'AcceptRole',
            'uuid': negotiation_id,
            'role': proposed_role,
            'agent_id': self.agent_id
        }
        await self.send_message(message['sender'], response)

        # Store negotiation state
        self.pending_systems[negotiation_id] = {
            'protocol': protocol_spec,
            'my_role': proposed_role
        }
    else:
        # Reject the role
        response = {
            'type': 'RejectRole',
            'uuid': negotiation_id,
            'reason': 'Role does not match capabilities'
        }
        await self.send_message(message['sender'], response)
\end{verbatim}

\paragraph{2. AcceptRole Handler (Initiator Agent).}
\begin{verbatim}
async def handle_accept_role(self, message):
    negotiation_id = message['uuid']
    role = message['role']
    agent_id = message['agent_id']

    # Update role bindings
    negotiation = self.active_negotiations[negotiation_id]
    negotiation['role_bindings'][role] = agent_id

    # Check if all roles are filled
    required_roles = set(negotiation['protocol'].roles)
    filled_roles = set(negotiation['role_bindings'].keys())

    if required_roles == filled_roles:
        # System complete, broadcast details
        system_details = {
            'type': 'SystemDetails',
            'uuid': negotiation_id,
            'protocol': negotiation['protocol'].name,
            'role_bindings': negotiation['role_bindings']
        }

        for agent_uri in negotiation['role_bindings'].values():
            await self.send_message(agent_uri, system_details)

        # Transition to enactment
        system_id = negotiation_id
        self.add_system(system_id, negotiation['protocol'].name,
                       negotiation['role_bindings'])
\end{verbatim}

\paragraph{3. SystemDetails Handler (All Agents).}
\begin{verbatim}
async def handle_system_details(self, message):
    system_id = message['uuid']
    protocol_name = message['protocol']
    role_bindings = message['role_bindings']

    # Register system with Adapter
    self.add_system(system_id, protocol_name, role_bindings)

    # Determine my role in the system
    my_role = None
    for role, agent_id in role_bindings.items():
        if agent_id == self.agent_id:
            my_role = role
            break

    # Transition to enactment mode
    self.current_system = system_id
    self.current_role = my_role

    logger.info(f"System {system_id} formed. My role: {my_role}")

    # Enable protocol execution
    await self.start_protocol_enactment()
\end{verbatim}

\subsection{Integration with Yggdrasil Platform}

The implementation integrates with Yggdrasil~\cite{yggdrasil}, a hypermedia middleware that provides workspace hosting, artifact management, and HTTP-based resource access.

\paragraph{Workspace Hosting.}
Yggdrasil exposes workspaces as REST resources:
\begin{itemize}
    \item \texttt{GET /workspaces/\{id\}}: Returns workspace metadata (RDF) including artifacts, agents, and sub-workspace links.
    \item \texttt{POST /workspaces/\{id\}/agents}: Registers an agent's Thing Description in the workspace.
    \item \texttt{DELETE /workspaces/\{id\}/agents/\{agent\_id\}}: Deregisters an agent.
    \item \texttt{GET /workspaces/\{id\}/artifacts}: Returns artifacts available in the workspace (RDF).
\end{itemize}

\paragraph{Artifact Management.}
Artifacts are stored as RDF resources with hypermedia controls:
\begin{verbatim}
GET /artifacts/rug

Response (Turtle):
@prefix ex: <http://example.org/> .

<#artifact> a ex:Rug ;
    ex:hasProtocol </protocols/buy> ;
    ex:price "100" ;
    ex:currency "USD" .
\end{verbatim}
The \texttt{ex:hasProtocol} link enables protocol discovery via hypermedia navigation.

\paragraph{Protocol Repository.}
Protocols are hosted as static JSON resources:
\begin{verbatim}
GET /protocols/buy

Response (JSON):
{
  "name": "Buy",
  "roles": ["Buyer", "Seller"],
  ...
}
\end{verbatim}
Agents download protocols via HTTP and parse them using the BSPL parser.

\subsection{Development Patterns and Usage}

This section describes common patterns for developing agents using the framework.

\subsubsection{Pattern 1: Fully Autonomous Agent}

For maximum autonomy, agents specify only goals, capabilities, and artifact classes:
\begin{verbatim}
adapter = HypermediaMetaAdapter(
    base_uri="http://localhost:8080",
    goal_type="gr:Buy",
    capabilities={"Pay"},
    goal_artifact_class="ex:Rug",
    auto_discover_workspace=True
)
await adapter.discover_and_propose_system()
\end{verbatim}
This pattern requires comprehensive semantic metadata (role semantics, artifact types, protocol links) but minimizes agent code.

\subsubsection{Pattern 2: Workspace-Scoped Agent}

For scenarios where the workspace is known but roles are dynamic:
\begin{verbatim}
adapter = HypermediaMetaAdapter(
    base_uri="http://localhost:8080",
    goal_type="gr:Sell",
    capabilities={"Give"}
)
await adapter.join_workspace("http://localhost:8080/workspaces/marketplace")

# Listen for role offers
adapter.on("OfferRole", handle_offer)
await adapter.run()
\end{verbatim}
This pattern suits reactive agents that respond to negotiation requests rather than initiating.

\subsubsection{Pattern 3: Protocol-Specific Agent}

For agents that enact known protocols but discover artifacts:
\begin{verbatim}
adapter = HypermediaMetaAdapter(
    base_uri="http://localhost:8080",
    goal_artifact_class="ex:Rug"
)

# Discover workspace and artifact
workspace_uri, artifact_uri = await adapter.discover_workspace_by_class()

# Manually specify protocol and role
await adapter.add_protocol_from_uri("http://localhost:8080/protocols/buy")
my_role = "Buyer"

# Discover partners and form system
candidates = await adapter.discover_candidate_agents()
await adapter.propose_system("Buy", my_role, candidates)
\end{verbatim}
This pattern offers a middle ground: semantic discovery with manual protocol/role selection.

\subsection{Code Metrics and Complexity}

Table~\ref{tab:code_metrics} summarizes the implementation's size and complexity.

\begin{table}[h]
\centering
\begin{tabular}{lrrr}
\toprule
\textbf{Component} & \textbf{Lines} & \textbf{Classes} & \textbf{Methods} \\
\midrule
Adapter (Protocol Engine) & 800 & 1 & 25 \\
MetaAdapter (Negotiation) & 400 & 1 & 12 \\
HypermediaMetaAdapter & 556 & 1 & 18 \\
HypermediaTools & 1,265 & 0 & 35 \\
Example Agents & 500 & 3 & 15 \\
\midrule
\textbf{Total} & \textbf{3,521} & \textbf{6} & \textbf{105} \\
\bottomrule
\end{tabular}
\caption{Code metrics for the implementation.}
\label{tab:code_metrics}
\end{table}

The implementation achieves significant functionality with modest code size, reflecting the leverage gained from declarative specifications (BSPL, RDF) and standards-based components (RDFLib, HTTP).

\subsection{Summary}

This chapter has described the implementation of the conceptual framework through a three-layer architecture:
\begin{itemize}
    \item \textbf{Layer 1 (Protocol Engine)}: \texttt{Adapter} and \texttt{MetaAdapter} provide BSPL enactment, formal verification, and role negotiation.
    \item \textbf{Layer 2 (Hypermedia Coordination)}: \texttt{HypermediaMetaAdapter} and \texttt{HypermediaTools} enable workspace discovery, semantic reasoning, and artifact location.
    \item \textbf{Layer 3 (Agent Implementation)}: Example agents demonstrate fully autonomous, reactive, and protocol-specific patterns.
\end{itemize}

The implementation realizes the key innovations:
\begin{itemize}
    \item \textbf{Semantic role reasoning} via goal-capability matching against RDF role semantics.
    \item \textbf{Class-based discovery} through hypermedia crawling with SPARQL filtering.
    \item \textbf{Dynamic role negotiation} using a universal BSPL metaprotocol.
\end{itemize}

Integration with the Yggdrasil platform provides workspace hosting, artifact management, and hypermedia controls. The result is a modular, standards-compliant system that enables agents to coordinate autonomously in open environments using only high-level goals, capabilities, and semantic types.

The next chapter evaluates the implementation's effectiveness through experiments and case studies.